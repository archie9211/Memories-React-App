import toast from "react-hot-toast";

// Updated Memory Interface
export interface Memory {
      id: string;
      user_id: string; // Original author
      type: "quote" | "image" | "video" | "hybrid";
      content?: string | null;
      asset_key?: string | null;
      caption?: string | null;
      location?: string | null;
      memory_date: string; // ISO string format
      created_at: string; // ISO string format
      updated_at?: string | null; // ISO string format
      edited_by?: string | null; // Editor's email
      tags?: string | null; // Comma-separated string from DB
}

// Interface for API response for fetching memories
export interface FetchMemoriesResponse {
      memories: Memory[];
      nextCursor: { date: string; id: string } | null;
}

// Interface for filtering parameters
export interface MemoryFilters {
      q?: string;
      location?: string;
      startDate?: string; // YYYY-MM-DD
      endDate?: string; // YYYY-MM-DD
      tags?: string; // Comma-separated
      limit?: number;
      cursorDate?: string; // ISO date string from last item
      cursorId?: string; // ID from last item
}

const API_BASE = "/api";

// --- Helper for Error Handling ---
const handleApiError = async (
      response: Response,
      defaultMessage: string
): Promise<void> => {
      let errorMessage = defaultMessage;
      try {
            const errorData = await response.json();
            errorMessage = errorData.error || errorData.message || errorMessage;
            if (errorData.details) {
                  errorMessage += ` (${errorData.details})`;
            }
      } catch (e) {
            // Ignore if response is not JSON
      }
      console.error("API Error:", response.status, errorMessage);
      toast.error(errorMessage); // Show toast notification
      throw new Error(errorMessage); // Still throw for component handling if needed
};

// Fetch memories with filtering and pagination
export const fetchMemories = async (
      filters: MemoryFilters
): Promise<FetchMemoriesResponse> => {
      const params = new URLSearchParams();
      if (filters.q) params.append("q", filters.q);
      if (filters.location) params.append("location", filters.location);
      if (filters.startDate) params.append("startDate", filters.startDate);
      if (filters.endDate) params.append("endDate", filters.endDate);
      if (filters.tags) params.append("tags", filters.tags);
      if (filters.limit) params.append("limit", filters.limit.toString());
      if (filters.cursorDate && filters.cursorId) {
            params.append("cursorDate", filters.cursorDate);
            params.append("cursorId", filters.cursorId);
      }

      const response = await fetch(`${API_BASE}/memories?${params.toString()}`);

      if (!response.ok) {
            await handleApiError(response, "Failed to fetch memories");
            return { memories: [], nextCursor: null }; // Should not be reached due to throw
      }
      return response.json();
};

interface UploadAssetResponse {
      key: string; // The key generated by the backend
}

export const uploadAsset = async (file: File): Promise<UploadAssetResponse> => {
      const formData = new FormData();
      formData.append("file", file); // Key must be 'file' (matching backend)

      const response = await fetch(`${API_BASE}/assets`, {
            method: "POST",
            body: formData,
            // DO NOT set 'Content-Type': 'multipart/form-data' manually!
            // The browser will set it correctly with the boundary when using FormData.
      });

      if (!response.ok) {
            await handleApiError(
                  response,
                  `Failed to upload ${file.type.split("/")[0] || "file"}`
            );
            // Ensure a fallback return or that handleApiError always throws
            throw new Error("Upload failed after handling API error.");
      }
      return response.json();
};

export const getAssetPath = (
      assetKey: string | null | undefined
): string | null => {
      if (!assetKey) {
            return null;
      }
      // Need to ensure the key is properly encoded for use in a URL path segment
      const encodedKey = encodeURIComponent(assetKey);
      return `${API_BASE}/assets/${encodedKey}`;
};

// Get Asset View URL (no changes needed)
export const getAssetViewUrl = async (assetKey: string): Promise<string> => {
      const encodedKey = encodeURIComponent(assetKey);
      const response = await fetch(`${API_BASE}/asset-url/${encodedKey}`);
      if (!response.ok)
            await handleApiError(response, "Failed to get asset URL");
      const data = await response.json();
      return data.url;
};

// Add Memory Payload
export interface AddMemoryPayload {
      type: "quote" | "image" | "video" | "hybrid";
      content?: string;
      asset_key?: string;
      caption?: string;
      location?: string;
      memory_date: string; // ISO 8601 format
      tags?: string; // Comma-separated string
}

// Update Memory Payload (Partial<AddMemoryPayload>)
export type UpdateMemoryPayload = Partial<AddMemoryPayload>;

export const addMemory = async (payload: AddMemoryPayload): Promise<Memory> => {
      const response = await fetch(`${API_BASE}/memories`, {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify(payload),
      });
      if (!response.ok) await handleApiError(response, "Failed to add memory");
      const data = await response.json();
      toast.success("Memory added!");
      return data.memory;
};

// Update Memory (Remains the same - relies on asset_key being passed in payload if changed)
export const updateMemory = async (
      id: string,
      payload: UpdateMemoryPayload
): Promise<Memory> => {
      const response = await fetch(`${API_BASE}/memories/${id}`, {
            method: "PATCH",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify(payload),
      });
      if (!response.ok)
            await handleApiError(response, "Failed to update memory");
      const data = await response.json();
      toast.success("Memory updated!");
      return data.memory;
};

// Get user info - Optional endpoint if needed for display
// export const getUserInfo = async (): Promise<{ email: string | null }> => {
//     try {
//         const response = await fetch('/api/userinfo'); // Assuming you create this simple endpoint
//         if (!response.ok) return { email: null };
//         return await response.json();
//     } catch {
//         return { email: null };
//     }
// };
